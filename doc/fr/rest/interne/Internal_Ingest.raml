#%RAML 0.8
title: Ingest Internal Module
baseUri: http://server-internal/ingest/{version}
version: v0.0.5
protocols: [ HTTP ]

mediaType: application/json

securitySchemes:
  - x-vitam-platform-key:
      type: x-hedader-key
      description: Vitam Platform Key
      describedBy:
        headers:
          x-vitam-key:
            type: string

securedBy: [ x-vitam-platform-key ]

schemas:
  - error: !include schema/error.json
  - async_status: !include schema/async_status.json
  - task_status: !include schema/task_status.json
  - answear: !include schema/answear.json
  - answearList: !include schema/answearList.json
  - collectionList: !include schema/collection_list.json
  - collectionQuery: !include schema/collection_query.json
  - genericObject: !include schema/generic_object.json
  - projection: !include schema/projection.json

traits: !include traits/Traits.raml

resourceTypes: !include resourceTypes/InternalResourceTypes.raml

documentation:
  - title: Ingests
    content: |
      Le principe proposé serait le suivant:
        - Permet de soumettre un SIP:
          - POST /ingests
        - Permet de suivre son exécution
          - GET /ingests/id_async
        - Permet de suivre les opérations
          - GET /ingests

      Questions ou remarques:
        - Plus tard ingests sera étendu aux cas de construction programatique d'un SIP:
          - Plusieurs requêtes commençant par un POST /ingests pour créer un contexte id_async
          - Autres requêtes pour ajouter des Units, des ObjectGroups
          - Puis enfin une requête pour commiter l'opération (PATCH /ingests/id_async)
        - Le post doit être pris comme un stream et non matérialisé (matérialisé sur l'espace de travail)

# Ingest
/ingests:
  # root endpoint request
  displayName: Ingests
  description: API de versement (Ingest). Ce point d'entrée permet de chercher ou de créer une transaction de versement. Une transaction de versement est volatile, c'est à dire qu'elle disparaîtra dès qu'elle sera terminée.
  type: base
  is: [ standardErrors ]
  get:
    description: Liste les opérations d'entrées en cours
    body:
      application/json:
        schema: collectionQuery
        example: !include samples/collectionQuery.sample
    responses:
      200:
        body:
          application/json:
            schema: collectionList
            example: !include samples/collectionList.sample
  post:
    description: |
      Crée une transaction d'entrée :
      - une requête unique, avec un 'body' contenant toutes les informations (Métadonnées dans un foirmat SEDA XML ou Json ainsi que tous les binaires) probablement dans un ZIP
      - d'autres formes (multi request through JSON) suivront
    body:
      application/zip:
      multipart/form-data:
        formParameters:
          file:
            description: The ZIP to be uploaded
            required: true
            type: file
          operations:
            description: the lokbook operations proxy as json in string
            required: true
            type: string
            example: !include samples/sampleLogbooks.sample
    responses:
      202:
        body:
          application/json:
            schema: genericObject
            example: !include samples/sampleTransfer.sample

  /{id_async}:
    displayName: Ingest
    description: Accès à une transaction d'entrée.
    type: { collection-item-write: { answearModel: async_status, exampleAnswearModel: !include samples/async_status.sample } }
    is: [ standardErrors ]
    get:
      description: Retourne le statut courant de cette transaction de versement.
      responses:
        202:
          description: La procédure n'est pas encore terminée
          body:
            application/json:
        200:
          description: La procédure est terminée et retourne le résultat
          body:
            application/json:
            application/xml:

/status:
  displayName: Ingest Module Status
  description: Statut du module d'entrée.
  type: { statusCollection }
  is: [ standardErrors, standardHeaders ]
