<?xml version="1.0" encoding="UTF-8"?>
<con:soapui-project id="c8480034-0dce-4dac-a1f2-c088e879b614" activeEnvironment="Default" name="TestSIP" resourceRoot="" soapui-version="5.3.0" abortOnError="false" runType="SEQUENTIAL" defaultScriptLanguage="Groovy" xmlns:con="http://eviware.com/soapui/config"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.actions.iface.tools.soapui.TestRunnerAction@values-local"><![CDATA[<xml-fragment xmlns:con="http://eviware.com/soapui/config">
  <con:entry key="Environment" value="Default"/>
  <con:entry key="Global Properties" value=""/>
  <con:entry key="TestSuite" value="TestSuite ingest US 655/946"/>
  <con:entry key="Password" value=""/>
  <con:entry key="TestRunner Path" value=""/>
  <con:entry key="Tool Args" value=""/>
  <con:entry key="Ignore Errors" value="false"/>
  <con:entry key="Host:Port" value=""/>
  <con:entry key="user-settings.xml Password" value=""/>
  <con:entry key="WSS Password Type" value=""/>
  <con:entry key="Save Project" value="false"/>
  <con:entry key="Enable UI" value="false"/>
  <con:entry key="System Properties" value=""/>
  <con:entry key="Domain" value=""/>
  <con:entry key="Coverage Report" value="false"/>
  <con:entry key="Export JUnit Results" value="false"/>
  <con:entry key="Export JUnit Results with test properties" value="false"/>
  <con:entry key="Open Report" value="false"/>
  <con:entry key="Project Properties" value=""/>
  <con:entry key="Export All" value="false"/>
  <con:entry key="Project Password" value=""/>
  <con:entry key="Report Format(s)" value=""/>
  <con:entry key="TestCase" value="Loop SIP"/>
  <con:entry key="Print Report" value="false"/>
  <con:entry key="Username" value=""/>
  <con:entry key="Root Folder" value=""/>
  <con:entry key="Select Report Type" value=""/>
  <con:entry key="Save After" value="false"/>
  <con:entry key="Add Settings" value="false"/>
  <con:entry key="Endpoint" value=""/>
</xml-fragment>]]></con:setting></con:settings><con:testSuite id="3738c27b-9369-49bf-82cf-ca1f835e1d56" name="TestSuite"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.panels.testcase.JTestRunLog$OptionsForm@max_rows">1000</con:setting><con:setting id="com.eviware.soapui.impl.wsdl.panels.testcase.JTestRunLog$OptionsForm@errors_only">false</con:setting></con:settings><con:runType>SEQUENTIAL</con:runType><con:testCase id="3f83a299-20d7-4e96-bee8-f15112f5a389" failOnError="false" failTestCaseOnErrors="true" keepSession="false" maxResults="0" name="SIPTEST" searchProperties="true" timeout="0" wsrmEnabled="false" wsrmVersion="1.0" wsrmAckTo="" amfAuthorisation="false" amfEndpoint="" amfLogin="" amfPassword=""><con:settings/><con:testStep type="groovy" name="init" id="7772c6d0-3604-44b8-9d9b-b683c04d9c3f"><con:settings/><con:config><script>/*******************************************************************************
 * Copyright French Prime minister Office/SGMAP/DINSIC/Vitam Program (2015-2019)
 *
 * contact.vitam@culture.gouv.fr
 *
 * This software is a computer program whose purpose is to implement a digital archiving back-office system managing
 * high volumetry securely and efficiently.
 *
 * This software is governed by the CeCILL 2.1 license under French law and abiding by the rules of distribution of free
 * software. You can use, modify and/ or redistribute the software under the terms of the CeCILL 2.1 license as
 * circulated by CEA, CNRS and INRIA at the following URL "http://www.cecill.info".
 *
 * As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the license,
 * users are provided only with a limited warranty and the software's author, the holder of the economic rights, and the
 * successive licensors have only limited liability.
 *
 * In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
 * developing or reproducing the software by the user in light of its specific status of free software, that may mean
 * that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
 * experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
 * software's suitability as regards their requirements in conditions enabling the security of their systems and/or data
 * to be ensured and, more generally, to use and operate it in the same conditions as regards security.
 *
 * The fact that you are presently reading this means that you have had knowledge of the CeCILL 2.1 license and that you
 * accept its terms.
 *******************************************************************************/

// defition du json 
def inputJSON = context.inputJSON 
log.info '#### Debut  du test ####' 
// iterator 

def i = context.iteration 

if ( context.inputJSON!= null &amp;&amp;   context.inputJSON.params.size  > 0 ){
	context.testName		= inputJSON.params[i].testName
	context.sipName		= inputJSON.params[i].sipName
	context.category		= inputJSON.params[i].category
	context.httpStatusCode 	= inputJSON.params[i].httpStatusCode
	context.result 		= true 
	context.expected 		= inputJSON.params[i].expected

} 

</script></con:config></con:testStep><con:testStep type="groovy" name="upload-http-builder" id="c54e8486-2efa-41d1-b080-bf72baaed437"><con:settings/><con:config><script>/*******************************************************************************
 * Copyright French Prime minister Office/SGMAP/DINSIC/Vitam Program (2015-2019)
 *
 * contact.vitam@culture.gouv.fr
 *
 * This software is a computer program whose purpose is to implement a digital archiving back-office system managing
 * high volumetry securely and efficiently.
 *
 * This software is governed by the CeCILL 2.1 license under French law and abiding by the rules of distribution of free
 * software. You can use, modify and/ or redistribute the software under the terms of the CeCILL 2.1 license as
 * circulated by CEA, CNRS and INRIA at the following URL "http://www.cecill.info".
 *
 * As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the license,
 * users are provided only with a limited warranty and the software's author, the holder of the economic rights, and the
 * successive licensors have only limited liability.
 *
 * In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
 * developing or reproducing the software by the user in light of its specific status of free software, that may mean
 * that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
 * experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
 * software's suitability as regards their requirements in conditions enabling the security of their systems and/or data
 * to be ensured and, more generally, to use and operate it in the same conditions as regards security.
 *
 * The fact that you are presently reading this means that you have had knowledge of the CeCILL 2.1 license and that you
 * accept its terms.
 *******************************************************************************/
/**
 * Upload File 
 **/
import java.security.KeyStore
import org.apache.http.conn.scheme.Scheme
import org.apache.http.conn.ssl.SSLSocketFactory
import org.apache.http.conn.ssl.AllowAllHostnameVerifier
import java.io.File;
import java.io.FileInputStream;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.InputStreamEntity;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.util.EntityUtils;

def url  = context.ingest+"ingest-external/v1/ingests/"
log.info 'Url for ingest' + url

def cert = context.certfile
def certPass = context.certPass

def trust = context.truststore
def trustPass = context.trustPass

def file = context.dataDir+context.sipName

log.info 'Cert: ' + cert
log.info 'File uploaded: ' + context.dataDir+context.sipName
def ope_id = null


def http = new DefaultHttpClient();
if (url.startsWith('https')) {
	def keyStore = KeyStore.getInstance( "PKCS12" )
	def trustStore = KeyStore.getInstance("JKS")
	//def keyStore = KeyStore.getInstance( "TLS" )
	
	new File(cert).withInputStream  {
    		keyStore.load(it, certPass.toCharArray() )
	}
	new File(trust).withInputStream {
		trustStore.load(it, trustPass.toCharArray())
	}
	SSLSocketFactory socketFactory = new SSLSocketFactory(keyStore,certPass , trustStore )
	//socketFactory.setHostnameVerified( new AllowAllHostnameVerifier() )
	socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
	http.connectionManager.schemeRegistry.register( new Scheme("https", socketFactory, 443 ) )
}
HttpPost httppost = new HttpPost(url);
            def reqEntity = new InputStreamEntity(
                    new FileInputStream(file), -1);
            reqEntity.setContentType("application/octet-stream");
            reqEntity.setChunked(true);
httppost.setEntity(reqEntity);
log.info "executing request " + httppost.getRequestLine();
 def response = http.execute(httppost);

context.ope_id =response.getFirstHeader('X-REQUEST-ID').getValue()
 </script></con:config></con:testStep><con:testStep type="groovy" name="details" id="b6877300-39ac-40de-a7d4-17e228892c0a"><con:settings/><con:config><script><![CDATA[import groovy.json.JsonSlurper
import groovy.json.JsonOutput
import java.security.KeyStore

import groovy.json.JsonSlurper
import org.apache.http.conn.scheme.Scheme
import org.apache.http.conn.ssl.SSLSocketFactory
import org.apache.http.conn.ssl.AllowAllHostnameVerifier
import org.apache.http.client.methods.HttpGet;
import java.io.File;
import java.io.FileInputStream;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.InputStreamEntity;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.util.EntityUtils;
import org.apache.http.entity.StringEntity;

def i = context.iteration
def url  = context.logbook+"access-external/v1/operations/" + context.ope_id
if (context.inputJSON.params[i].category != "EVT_UPLOAD_SIP")
{
	url  = context.access + context.inputJSON.params[i].operations.endpoint;	
}
def options = "" 
def cert = context.certfile
def certPass = context.certPass
def trust = context.truststore
def trustPass = context.trustPass
def reponse =  null

def http = new DefaultHttpClient();
if (url.startsWith('https')) {
	def keyStore = KeyStore.getInstance( "PKCS12" )
	def trustStore = KeyStore.getInstance("JKS")
	//def keyStore = KeyStore.getInstance( "TLS" )
	
	new File(cert).withInputStream  {
    		keyStore.load(it, certPass.toCharArray() )
	}
	new File(trust).withInputStream {
		trustStore.load(it, trustPass.toCharArray())
	}
	SSLSocketFactory socketFactory = new SSLSocketFactory(keyStore,certPass , trustStore )
	//socketFactory.setHostnameVerified( new AllowAllHostnameVerifier() )
	socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
	http.connectionManager.schemeRegistry.register( new Scheme("https", socketFactory, 443 ) )
}

def response = null;

if ((context.inputJSON.params[i].category != "EVT_UPLOAD_SIP") && (context.inputJSON.params[i].category != "EVT_IMPORT_RULES")){

	context.outputJson.params[context.outIteration] = new JsonSlurper().parseText('{}')
	context.outputJson.params[context.outIteration].testName = context.testName;
 	if (resultStatusControl(context.response, context.inputJSON.params[i].testsExpected.httpStatusCode) &&
 		resultEntityControl(context.response, context.testName, context.outIteration)){
 		context.outputJson.params[context.outIteration].result = true;		
	} else {
		context.outputJson.params[context.outIteration].result = false;
	}
	context.outIteration = context.outIteration + 1

}else {

	/********************************************************************/
	if (context.inputJSON.params[i].category == "EVT_UPLOAD_SIP")
{
	HttpGet httpGet = new HttpGet(url);
	response = http.execute(httpGet);

} else {	
	HttpPost httpPost = new HttpPost(url);		
	StringEntity reqEntity = new StringEntity('{\"$roots\":[],\"$query\":[],\"$filter\":{},\"$projection\":{}}');
	reqEntity.setContentType("application/json");
	httpPost.setEntity(reqEntity);		
	response = http.execute(httpPost);		
}

	if ((response !=null )  && (context.inputJSON.params[i].category == "EVT_UPLOAD_SIP")){
		def result  = new JsonSlurper().parseText(EntityUtils.toString(response.entity))  // $.result[*]
		log.error result 
		//result = reponse
		def size = result.$results[0].events.size
	
		log.info 'Size / Last elem: ' + size + ' / ' + size-1
		log.info 'Item -1: ' + result.$results[0].events[size-1].evType
		log.info 'Outcome: ' + result.$results[0].events[size-1].outcome
	
		// Operation result
		resultat =  result.$results[0].events[size-1].outcome == context.expected
	
		if (context.inputJSON.params[i].actions != null) {
	
			// boucler sur les actions
			def actionsSize = context.inputJSON.params[i].actions.size
			for (a = 0; a < actionsSize; a++) {
				currentAction = context.inputJSON.params[i].actions[a].name
				context.outputJson.params[context.outIteration] = new JsonSlurper().parseText('{}')
				context.outputJson.params[context.outIteration].ope_id = context.ope_id
				context.outputJson.params[context.outIteration].currentAction = currentAction
	
				// Copy parameters
				context.outputJson.params[context.outIteration].sipName = context.inputJSON.params[i].sipName
				context.outputJson.params[context.outIteration].expected = context.inputJSON.params[i].expected
				context.outputJson.params[context.outIteration].httpStatusCode = context.inputJSON.params[i].httpStatusCode
				context.outputJson.params[context.outIteration].testName = context.inputJSON.params[i].testName
				context.outputJson.params[context.outIteration].category = context.inputJSON.params[i].category
				for (j = 0; j < size; j++) {
					currentEventType = result.$results[0].events[j].evType
					currentEventOutCome = result.$results[0].events[j].outcome
					if (currentAction == currentEventType && currentEventOutCome != 'STARTED') {
						log.info 'outIteration : ' + context.outIteration
						context.outputJson.params[context.outIteration].expected = context.inputJSON.params[i].actions[a].expected
						context.outputJson.params[context.outIteration].observed = result.$results[0].events[j].outcome
						context.outputJson.params[context.outIteration].result = context.outputJson.params[context.outIteration].expected == context.outputJson.params[context.outIteration].observed
						break;
					}
				}
				log.info 'outputJson : ' + context.outputJson
				context.outIteration = context.outIteration + 1
			}
		}
		else {
			//maintain compatibility
			context.outputJson.params[context.outIteration] = new JsonSlurper().parseText('{}')

			// Copy parameters
			context.outputJson.params[context.outIteration].sipName = context.inputJSON.params[i].sipName
			context.outputJson.params[context.outIteration].expected = context.inputJSON.params[i].expected
			context.outputJson.params[context.outIteration].httpStatusCode = context.inputJSON.params[i].httpStatusCode
			context.outputJson.params[context.outIteration].testName = context.inputJSON.params[i].testName
			context.outputJson.params[context.outIteration].category = context.inputJSON.params[i].category
			context.outputJson.params[context.outIteration].ope_id = context.ope_id
			context.outputJson.params[context.outIteration].expected = context.expected
			context.outputJson.params[context.outIteration].observed = result.$results[0].events[size-1].outcome
			context.outputJson.params[context.outIteration].result = resultat
			context.outIteration = context.outIteration + 1
		}
	
	log.info 'OUTPUT JSON : '+context.outputJson.params.text
	log.info "------------------------------------->resultat observé : "+ result.$results[0].events[size-1].outcome
	
} else if ((response !=null )  && (context.inputJSON.params[i].category != "EVT_UPLOAD_SIP")){
		context.outputJson.params[context.outIteration] = new JsonSlurper().parseText('{}')			

		def result  = new JsonSlurper().parseText(EntityUtils.toString(response.entity))  // $.result[*]
		log.info result 
		
		if (result.$hits.total == context.inputJSON.params[i].testsExpected.ruleNumber) {
			context.outputJson.params[context.outIteration].result = true;		
		}
		else context.outputJson.params[context.outIteration].result = false;		
			
		context.outputJson.params[context.outIteration].ruleFileName = "testRule"		
		context.outputJson.params[context.outIteration]._tenant = 0
		context.outputJson.params[context.outIteration].expected = "impoted"
		context.outputJson.params[context.outIteration].httpStatusCode = 201
		context.outputJson.params[context.outIteration].testName = "import regle avectenant 0"
		
		context.outIteration = context.outIteration + 1
}

 	/********************************************************************/
}


boolean resultStatusControl(HttpResponse response, int code){
	if (response.getStatusLine().getStatusCode() == code){
		return true;
	} else {
		return false;
	}	
}

boolean resultEntityControl(HttpResponse response, String testName, int outIteration){
	def result  = new JsonSlurper().parseText(EntityUtils.toString(response.entity))		
	if (testName == "REFRG1"){
		//log.info "*************************************" + result.$hits.total;
		//log.info "*************************************" + context.inputJSON.params[context.iteration].testsExpected.ruleNumber;
		if (result.$hits.total != context.inputJSON.params[context.iteration].testsExpected.ruleNumber){
			context.outputJson.params[outIteration].error = "total";
			return false;
		} else {
			
			context.outputJson.params[outIteration].hits_total = result.$hits.total;

			for (int i=0; i<result.$hits.total; i++){
				log.info "*************************************" + result.$results[i].RuleId;
				log.info "*************************************" + context.inputJSON.params[context.iteration].testsExpected.content[i];
				
				if (result.$results[i].RuleId != context.inputJSON.params[context.iteration].testsExpected.content[i]){
					context.outputJson.params[outIteration].error = "results[" + i + "]";
					return false;
				} else {
					context.outputJson.params[outIteration].content = result.$results[i].RuleId;
				}
			}

			return true;
		}
	} else if (testName == "REFRMT1"){
		log.info "*************************************" + result.$hits.total;
		if (result.$hits.total != context.inputJSON.params[context.iteration].testsExpected.formatNumber){
			context.outputJson.params[outIteration].error = "total";
			return false;
		} else {
			context.outputJson.params[outIteration].formatNumber = result.$hits.total;
			context.outputJson.params[outIteration].content = [];
			for (int i=0; i<result.$hits.total; i++){
				log.info "*************************************" + result.$results[i].PUID;
				log.info "*************************************" + context.inputJSON.params[context.iteration].testsExpected.content[i];
				
				if (result.$results[i].PUID != context.inputJSON.params[context.iteration].testsExpected.content[i]){
					context.outputJson.params[outIteration].error = "results[" + i + "]";
					return false;
				} else {
					context.outputJson.params[outIteration].content.add(result.$results[i].PUID);
				}
			}
			
			return true;
		}
		 
	} else {
		return true;
	}
}

]]></script></con:config></con:testStep><con:testStep type="groovy" name="while" id="80a3a8e4-bc73-41e7-a411-48982e666a01"><con:settings/><con:config><script>

def inputJSON = context.inputJSON 
def i = context.iteration 

if ( context.inputJSON!= null &amp;&amp; i &lt; inputJSON.params.size -1 ) {
	context.iteration = (i +  1 )
	testRunner.gotoStep(0)
}
else {
	
}
log.info '### Fin du test'
</script></con:config></con:testStep><con:testStep type="groovy" name="report" id="666d2252-2a14-4ffc-95bb-817708297ebd"><con:settings/><con:config><script>
import groovy.json.JsonOutput
def  inputJSON = context.outputJson 
	log.info '#### GENERATION DU RAPPORT'
	log.info ' json'+context.outputJson
	log.info ' Nombre de tests '+context.outputJson.params.size
	
if ( context.outputJson!= null &amp;&amp; 0 &lt; context.outputJson.params.size  ) {
	def jsonOut = context.expand('${#Project#reportingDir}') + 'reporting.json'
	log.info jsonOut
	File jsonFile = new File(jsonOut)
	jsonFile.text= JsonOutput.toJson(context.outputJson)
	log.info 'Fin de tests'
}</script></con:config></con:testStep><con:setupScript>def configD =context.expand('${#Project#configDir}')
log.info ("\ncongig  directory :" + configD)
import groovy.json.JsonSlurper
def i = 0 ; 
def inputFile = new File(configD+"data.json")
def inputJSON = new JsonSlurper().parseText(inputFile.text)
def outputJson  = new JsonSlurper().parseText('{"params":[]}')

//define contexts

context.dataDir = context.expand('${#Project#dataDir}')
context.ingest = context.expand('${#Project#ingestHost}')
context.logbook = context.expand('${#Project#logbookHost}')
context.certfile = context.expand('${#Project#certfile}')
context.certPass = context.expand('${#Project#certPass}')

context.truststore = context.expand('${#Project#truststore}')
context.trustPass = context.expand('${#Project#trustPass}')

context.inputJSON = inputJSON
context.outputJson = outputJson 
context.inputFile =inputFile
context.iteration  = 0 ; 
context.outIteration  = 0 ; 
context.nbFail = 0 
context.nbsuccess= 0 

def items = []
context.items = items</con:setupScript>
<con:tearDownScript>//context.inputFile.close()</con:tearDownScript><con:properties/></con:testCase><con:properties/></con:testSuite>
<con:endpointStrategy xsi:type="con:DefaultEndpointStrategy" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:endpoint mode="COMPLEMENT" username="ykouki" password="">https://int.env.programmevitam.fr</con:endpoint></con:endpointStrategy>
<con:properties/><con:wssContainer>
<con:crypto>
	<con:source>/vitam/conf/tsa.p12</con:source>
	<con:password>vitam1234</con:password>
	<con:type>KEYSTORE</con:type>
</con:crypto>
<con:outgoing>
	<con:name>vitam</con:name>
	<con:username/>
	<con:password/>
	<con:entry type="Encryption" username="ihm_demo_int3" password="vitam1234">
		<con:configuration>
			<crypto>keystore_ihm-demo.p12</crypto>
			<keyIdentifierType>3</keyIdentifierType>
			<symmetricEncAlgorithm/>
			<encKeyTransport/>
			<embeddedKeyName/>
			<embeddedKeyPassword/>
			<encryptionCanonicalization/>
			<encryptSymmetricKey>true</encryptSymmetricKey>
		</con:configuration>
	</con:entry>
</con:outgoing>
</con:wssContainer>
<con:oAuth2ProfileContainer/>
<con:oAuth1ProfileContainer/><con:sensitiveInformation>
<ProjectSpecificExposureList>null###null</ProjectSpecificExposureList>
</con:sensitiveInformation>
</con:soapui-project>